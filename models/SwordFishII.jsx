/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Author: Kyaw.Zay.Ya (https://sketchfab.com/Kyaw.Zay.Ya)
License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
Source: https://sketchfab.com/3d-models/swordfish-ii-fan-art-aac759579ac54b4eaa97887a0129e75c
Title: Swordfish II - Fan Art
*/

import React, { useRef, useEffect } from 'react';
import { useGLTF } from '@react-three/drei';
import { useFrame, useThree} from '@react-three/fiber';
import swordFishIIScene from '../public/swordfish_ii_-_fan_art-2.glb';
import { a, useScroll } from '@react-spring/three'; //enable animations
import { useUpdate } from '@react-three/fiber';
import * as THREE from 'three';


export function swordFishII(props) {
  const { nodes, materials, scene, animation } = useGLTF(swordFishIIScene)
  const swordFishIIRef = useRef()
  const previousPosition = useRef(new THREE.Vector3(0, 0, 0)); // Stocke la position précédente
  const initialPosition = useRef(new THREE.Vector3(2, 1, 3));



  useFrame((state, delta) => {
    // Angle de rotation (en radians) pour simuler la rotation orbitale
    const angle = state.clock.elapsedTime * 0.3;

    // Nouvelles coordonnées du centre de l'orbite
    const centerX = 0;
    // const centerY = -6;
    const centerZ = -43;

    // Calcul des coordonnées x et z en fonction de l'angle et du rayon de l'orbite
    const x = Math.cos(angle) * props.orbitRadius + centerX;
    // const y = Math.sin(angle) * props.orbitRadius + centerY;
    const z = Math.sin(angle) * props.orbitRadius + centerZ;


    // Positionner l'objet à sa position orbitale
    swordFishIIRef.current.position.set(-x, 0, z);

// Calculer l'orientation cible (pointant vers le centre du disque)
// Calculer l'orientation cible (pointant vers le centre du disque)
  const currentPosition = new THREE.Vector3(-x, 0, z);
    const direction = currentPosition.clone().sub(previousPosition.current).normalize();

    // Stocker la position actuelle pour la prochaine itération
    previousPosition.current = currentPosition;

    // Appliquer la direction de déplacement à l'orientation du cube
    const targetOrientation = new THREE.Matrix4().lookAt(
      new THREE.Vector3(0, 0, 0),
      direction,
      new THREE.Vector3(0, 1, 0)
    );

    // Appliquer l'orientation cible à l'objet
    swordFishIIRef.current.position.set(-x, 0, z);
    swordFishIIRef.current.quaternion.setFromRotationMatrix(targetOrientation);

  });


return (
    <group ref={swordFishIIRef}{...props} >
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.defaultMaterial.geometry}
            material={materials.Wall}
            
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.defaultMaterial_1.geometry}
            material={materials.Wall}
            
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.defaultMaterial_2.geometry}
            material={materials.Wall}
            
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.defaultMaterial_3.geometry}
            material={materials.Wall}
            
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.defaultMaterial_4.geometry}
            material={materials.Wall}
            
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.defaultMaterial_5.geometry}
            material={materials.Wall}
            
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.defaultMaterial_6.geometry}
            material={materials.Wall}
            
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.defaultMaterial_7.geometry}
            material={materials.Wall}
            
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.defaultMaterial_8.geometry}
            material={materials.Wall}
            
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.defaultMaterial_9.geometry}
            material={materials.Wall}
            
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.defaultMaterial_10.geometry}
            material={materials.Wall}
            
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.defaultMaterial_11.geometry}
            material={materials.Wall}
            
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.defaultMaterial_12.geometry}
            material={materials.Wall}
            
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.defaultMaterial_13.geometry}
            material={materials.Wall}
            
          />
          {/* mesh 14: missile
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.defaultMaterial_14.geometry}
            material={materials.Wall}
            
          />{/* 
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.defaultMaterial_15.geometry}
            material={materials.Wall}
            
          /> */}
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.defaultMaterial_16.geometry}
            material={materials.Wall}
            
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.defaultMaterial_17.geometry}
            material={materials.Wall}
            
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.defaultMaterial_18.geometry}
            material={materials.Wall}
            
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.defaultMaterial_19.geometry}
            material={materials.Wall}
            
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.defaultMaterial_20.geometry}
            material={materials.Wall}
            
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.defaultMaterial_21.geometry}
            material={materials.Wall}
            
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.defaultMaterial_22.geometry}
            material={materials.Wall}
            
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.defaultMaterial_23.geometry}
            material={materials.Wall}
            
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.defaultMaterial_24.geometry}
            material={materials.Wall}
            
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.defaultMaterial_25.geometry}
            material={materials.Wall}
            
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.defaultMaterial_26.geometry}
            material={materials.Wall}
            
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.defaultMaterial_27.geometry}
            material={materials.Wall}
            
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.defaultMaterial_28.geometry}
            material={materials.Wall}
            
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.defaultMaterial_29.geometry}
            material={materials.Wall}
            
          />
    </group>
  )
}

export default swordFishII;
